#' Compare Von Bertalanffy Growth Parameters Between Groups Using Bootstrap Permutation Test
#'
#' This function performs a bootstrap permutation test to evaluate whether von Bertalanffy
#' growth parameters differ significantly between two or more groups. The test compares
#' the observed differences in parameters against a null distribution generated by
#' randomly permuting group labels.
#'
#' @param age A numeric vector of ages
#' @param length A numeric vector of lengths
#' @param group A factor or character vector specifying the group for each observation
#' @param sex Optional factor or character vector specifying sex for each observation (for sex-specific models)
#' @param n_bootstrap Number of bootstrap permutations (default 1000)
#' @param parameters Character vector of parameters to test. Options: "Linf", "k", "t0", "CV" (default all).
#'   For sex models, parameters are automatically expanded to sex-specific versions (e.g., "Linf_M", "Linf_F")
#' @param alpha Significance level for the test (default 0.05)
#' @param verbose Logical, whether to print progress messages (default TRUE)
#' @param seed Optional seed for reproducible results
#' @param min_obs Minimum number of observations required per sex/group combination (default 50).
#'   Combinations with fewer observations will be removed before analysis
#' @param age_stratified Logical, whether to use age-stratified permutation (default TRUE).
#'   When TRUE, permutations are performed within age bins to maintain age distribution
#' @param age_bin_width Width of age bins in years for stratified permutation (default 2).
#'   Only used when age_stratified = TRUE. Each bin will span this many years.
#' @param test_curves Logical, whether to test for differences in growth curves (default TRUE).
#'   This performs a permutation test on the maximum absolute deviance between fitted curves
#' @param curve_ages Optional numeric vector of ages at which to evaluate curves for comparison.
#'   If NULL, uses a sequence from min to max age with 0.5 year increments
#'
#' @return A list containing:
#' \itemize{
#'   \item \code{observed_diffs}: Observed differences between groups for each parameter
#'   \item \code{p_values}: P-values for each parameter comparison
#'   \item \code{significant}: Logical indicating which parameters show significant differences
#'   \item \code{group_parameters}: Parameter estimates for each group
#'   \item \code{null_distributions}: Bootstrap null distributions for each parameter
#'   \item \code{curve_comparison}: Results from growth curve comparison test (if test_curves = TRUE)
#'   \item \code{method_info}: Information about the test method and settings
#' }
#'
#' @details
#' The function fits separate von Bertalanffy models to each group, then performs
#' a bootstrap permutation test by:
#' \enumerate{
#'   \item Computing observed parameter differences between groups
#'   \item Randomly permuting group labels n_bootstrap times (with optional age stratification)
#'   \item Fitting models to each permuted dataset
#'   \item Computing parameter differences for each permutation
#'   \item Calculating p-values as the proportion of permuted differences
#'       that exceed the observed differences
#' }
#'
# When \code{age_stratified = TRUE} (default), permutations are performed within
#' age bins to ensure that age distributions remain comparable between groups.
#' This is crucial for validity as it tests differences in growth parameters
#' rather than differences in age distribution. Age bins are created using
#' \code{age_bin_width} to define the width of each bin in years.
#'
#' For multiple groups, the test statistic is the maximum pairwise difference
#' between any two groups for each parameter.
#'
#' @examples
#' \dontrun{
#' # Simulate data for two groups with different growth parameters
#' set.seed(123)
#' n_per_group <- 50
#' age1 <- runif(n_per_group, 1, 15)
#' age2 <- runif(n_per_group, 1, 15)
#'
#' # Group 1: Linf=100, k=0.2
#' length1 <- 100 * (1 - exp(-0.2 * (age1 - (-0.5)))) + rnorm(n_per_group, 0, 8)
#' # Group 2: Linf=120, k=0.15 (different parameters)
#' length2 <- 120 * (1 - exp(-0.15 * (age2 - (-0.5)))) + rnorm(n_per_group, 0, 10)
#'
#' age <- c(age1, age2)
#' length <- c(length1, length2)
#' group <- rep(c("Population_A", "Population_B"), each = n_per_group)
#'
#' # Test for differences in basic parameters
#' result <- compare_vb_mle(
#'   age = age, length = length, group = group,
#'   n_bootstrap = 500, seed = 123
#' )
#'
#' # Test with sex-specific models
#' sex <- rep(c("M", "F"), length.out = length(age))
#' result_sex <- compare_vb_mle(
#'   age = age, length = length, group = group, sex = sex,
#'   n_bootstrap = 500, seed = 123
#' )
#'
#' # View results
#' print(result$p_values)
#' print(result$significant)
#' print(result$group_parameters)
#' }
#'
#' @export
compare_vb_mle <- function(age, length, group, sex = NULL, n_bootstrap = 1000,
                           parameters = c("Linf", "k", "t0", "CV"),
                           alpha = 0.05, verbose = TRUE, seed = NULL, min_obs = 50,
                           age_stratified = TRUE, age_bin_width = 2,
                           test_curves = TRUE, curve_ages = NULL) {
  # Set seed for reproducibility if provided
  if (!is.null(seed)) {
    set.seed(seed)
  }

  # Input validation
  if (length(age) != length(length) || length(age) != length(group)) {
    stop("age, length, and group must have the same length")
  }

  if (!is.null(sex) && length(sex) != length(age)) {
    stop("sex must have the same length as age, length, and group")
  }

  # Remove missing values
  if (is.null(sex)) {
    complete_cases <- complete.cases(age, length, group)
    age <- age[complete_cases]
    length <- length[complete_cases]
    group <- as.factor(group)[complete_cases]
    sex <- NULL
  } else {
    complete_cases <- complete.cases(age, length, group, sex)
    age <- age[complete_cases]
    length <- length[complete_cases]
    group <- as.factor(group)[complete_cases]
    sex <- as.factor(sex)[complete_cases]
  }

  if (verbose) {
    cat("Removed", sum(!complete_cases), "incomplete cases\n")
    cat("Analysing", length(age), "observations\n")
  }

  # Filter out sex/group combinations with insufficient observations
  if (!is.null(sex) && min_obs > 0) {
    # Create sex/group combinations
    sex_group_combo <- interaction(sex, group, drop = TRUE)
    combo_counts <- table(sex_group_combo)

    # Identify combinations with sufficient observations
    sufficient_combos <- names(combo_counts)[combo_counts >= min_obs]

    if (length(sufficient_combos) == 0) {
      stop("No sex/group combinations have >= ", min_obs, " observations")
    }

    # Filter to keep only sufficient combinations
    keep_indices <- sex_group_combo %in% sufficient_combos

    if (sum(!keep_indices) > 0) {
      insufficient_combos <- names(combo_counts)[combo_counts < min_obs]
      if (verbose) {
        cat(
          "Removed", sum(!keep_indices), "observations from", length(insufficient_combos),
          "sex/group combinations with < ", min_obs, " observations:\n"
        )
        for (combo in insufficient_combos) {
          cat("  ", combo, ": ", combo_counts[combo], " observations\n", sep = "")
        }
      }

      age <- age[keep_indices]
      length <- length[keep_indices]
      group <- droplevels(group[keep_indices])
      sex <- droplevels(sex[keep_indices])

      if (verbose) {
        cat("Remaining", length(age), "observations for analysis\n")
      }
    }
  } else if (is.null(sex) && min_obs > 0) {
    # For non-sex models, filter groups with insufficient observations
    group_counts <- table(group)
    sufficient_groups <- names(group_counts)[group_counts >= min_obs]

    if (length(sufficient_groups) == 0) {
      stop("No groups have >= ", min_obs, " observations")
    }

    keep_indices <- group %in% sufficient_groups

    if (sum(!keep_indices) > 0) {
      insufficient_groups <- names(group_counts)[group_counts < min_obs]
      if (verbose) {
        cat(
          "Removed", sum(!keep_indices), "observations from", length(insufficient_groups),
          "groups with < ", min_obs, " observations:\n"
        )
        for (grp in insufficient_groups) {
          cat("  ", grp, ": ", group_counts[grp], " observations\n", sep = "")
        }
      }

      age <- age[keep_indices]
      length <- length[keep_indices]
      group <- droplevels(group[keep_indices])

      if (verbose) {
        cat("Remaining", length(age), "observations for analysis\n")
      }
    }
  }

  # Check we have at least 2 groups
  group_levels <- levels(group)
  if (length(group_levels) < 2) {
    stop("Need at least 2 groups for comparison")
  }

  if (verbose) {
    cat("Comparing", length(group_levels), "groups:", paste(group_levels, collapse = ", "), "\n")
    cat("Group sizes:", table(group), "\n")
  }

  # Validate parameters
  valid_params <- c("Linf", "k", "t0", "CV")
  if (!all(parameters %in% valid_params)) {
    stop("parameters must be a subset of: ", paste(valid_params, collapse = ", "))
  }

  # Helper function to extract parameters from model fit
  extract_parameters <- function(fit) {
    if (!is.null(fit$models)) {
      # Sex-specific models - parameters are in fit$models$sex$parameters
      params <- list()
      for (sex_level in names(fit$models)) {
        sex_model <- fit$models[[sex_level]]
        sex_params <- sex_model$parameters
        for (param in c("Linf", "k", "t0", "cv")) {
          param_name <- paste0(toupper(substring(param, 1, 1)), substring(param, 2), "_", sex_level)
          if (param == "cv") param_name <- paste0("CV_", sex_level)
          params[[param_name]] <- sex_params[[param]]
        }
      }
      return(unlist(params))
    } else {
      # Single model - parameters is a matrix with rownames and "estimate" column
      params <- fit$parameters
      result <- c(
        Linf = params["Linf", "estimate"],
        k = params["k", "estimate"],
        t0 = params["t0", "estimate"],
        CV = params["cv", "estimate"] # Note: lowercase "cv" in row, uppercase "CV" in result
      )
      return(result)
    }
  }

  # Function to fit VB model to a group and extract parameters
  fit_group_model <- function(group_age, group_length, group_sex = NULL, start_vals = NULL) {
    tryCatch(
      {
        # Load the fit_vb_mle function (assuming it's available)
        if (!exists("fit_vb_mle")) {
          stop("fit_vb_mle function not found. Please load the growthVB package.")
        }

        fit <- fit_vb_mle(age = group_age, length = group_length, sex = group_sex, start_values = start_vals)
        return(extract_parameters(fit))
      },
      error = function(e) {
        warning(paste("Failed to fit model:", e$message))
        return(NULL)
      }
    )
  }

  # Function to calculate maximum pairwise difference for each parameter
  calc_max_diff <- function(param_matrix) {
    n_groups <- nrow(param_matrix)
    max_diffs <- numeric(ncol(param_matrix))
    names(max_diffs) <- colnames(param_matrix)

    for (p in 1:ncol(param_matrix)) {
      param_vals <- param_matrix[, p]
      if (all(!is.na(param_vals))) {
        max_diffs[p] <- max(param_vals) - min(param_vals)
      } else {
        max_diffs[p] <- NA
      }
    }
    return(max_diffs)
  }

  # Function to calculate von Bertalanffy curve
  vb_curve <- function(age, Linf, k, t0) {
    Linf * (1 - exp(-k * (age - t0)))
  }

  # Function to extract curve parameters from fitted parameters
  extract_curve_params <- function(params, sex_level = NULL) {
    if (!is.null(sex_level)) {
      # Sex-specific parameters
      Linf <- params[[paste0("Linf_", sex_level)]]
      k <- params[[paste0("K_", sex_level)]]
      t0 <- params[[paste0("T0_", sex_level)]]
    } else {
      # Single model parameters
      Linf <- params[["Linf"]]
      k <- params[["k"]]
      t0 <- params[["t0"]]
    }
    return(list(Linf = Linf, k = k, t0 = t0))
  }

  # Function to calculate maximum curve deviance between groups
  calc_curve_deviance <- function(group_params, eval_ages, sex_levels = NULL) {
    n_groups <- nrow(group_params)
    group_names <- rownames(group_params)
    
    if (!is.null(sex_levels)) {
      # Sex-specific models: calculate deviance for each sex separately, then take maximum
      max_deviance_overall <- 0
      deviance_by_sex <- list()
      
      for (sex_level in sex_levels) {
        # Calculate curves for each group for this sex
        group_curves <- matrix(NA, nrow = n_groups, ncol = length(eval_ages))
        rownames(group_curves) <- group_names
        
        for (i in 1:n_groups) {
          curve_params <- extract_curve_params(group_params[i, ], sex_level)
          if (!any(is.na(unlist(curve_params)))) {
            group_curves[i, ] <- vb_curve(eval_ages, curve_params$Linf, 
                                         curve_params$k, curve_params$t0)
          }
        }
        
        # Calculate maximum pairwise deviance for this sex
        max_deviance_sex <- 0
        if (sum(complete.cases(group_curves)) >= 2) {
          for (i in 1:(n_groups-1)) {
            for (j in (i+1):n_groups) {
              if (!any(is.na(group_curves[i, ])) && !any(is.na(group_curves[j, ]))) {
                deviance_ij <- max(abs(group_curves[i, ] - group_curves[j, ]))
                max_deviance_sex <- max(max_deviance_sex, deviance_ij)
              }
            }
          }
        }
        
        deviance_by_sex[[sex_level]] <- max_deviance_sex
        max_deviance_overall <- max(max_deviance_overall, max_deviance_sex)
      }
      
      return(list(overall = max_deviance_overall, by_sex = deviance_by_sex))
      
    } else {
      # Single model: calculate curves for each group
      group_curves <- matrix(NA, nrow = n_groups, ncol = length(eval_ages))
      rownames(group_curves) <- group_names
      
      for (i in 1:n_groups) {
        curve_params <- extract_curve_params(group_params[i, ])
        if (!any(is.na(unlist(curve_params)))) {
          group_curves[i, ] <- vb_curve(eval_ages, curve_params$Linf, 
                                       curve_params$k, curve_params$t0)
        }
      }
      
      # Calculate maximum pairwise deviance
      max_deviance <- 0
      if (sum(complete.cases(group_curves)) >= 2) {
        for (i in 1:(n_groups-1)) {
          for (j in (i+1):n_groups) {
            if (!any(is.na(group_curves[i, ])) && !any(is.na(group_curves[j, ]))) {
              deviance_ij <- max(abs(group_curves[i, ] - group_curves[j, ]))
              max_deviance <- max(max_deviance, deviance_ij)
            }
          }
        }
      }
      
      return(list(overall = max_deviance))
    }
  }

  # Fit models to each group and get observed parameters
  if (verbose) cat("Fitting models to each group...\n")

  # First fit to determine parameter structure
  group_mask <- group == group_levels[1]
  group_age_test <- age[group_mask]
  group_length_test <- length[group_mask]
  group_sex_test <- if (!is.null(sex)) sex[group_mask] else NULL

  test_params <- fit_group_model(group_age_test, group_length_test, group_sex_test)
  if (is.null(test_params)) {
    stop("Failed to fit initial model to determine parameter structure")
  }

  # Determine which parameters to test based on model type
  available_params <- names(test_params)
  if (!is.null(sex)) {
    # For sex models, expand parameters to sex-specific versions
    test_parameters <- character(0)
    sex_levels <- levels(sex)
    for (param in parameters) {
      for (sex_level in sex_levels) {
        # Match the naming convention used in extract_parameters
        if (param == "CV") {
          param_name <- paste0("CV_", sex_level)
        } else {
          param_name <- paste0(toupper(substring(param, 1, 1)), substring(param, 2), "_", sex_level)
        }
        if (param_name %in% available_params) {
          test_parameters <- c(test_parameters, param_name)
        }
      }
    }
  } else {
    # For single models, use parameters as-is
    test_parameters <- intersect(parameters, available_params)
  }

  if (length(test_parameters) == 0) {
    stop("No valid parameters found for testing")
  }

  if (verbose) {
    cat("Testing parameters:", paste(test_parameters, collapse = ", "), "\n")
  }

  # Initialize parameter matrix and starting values storage
  group_params <- matrix(NA, nrow = length(group_levels), ncol = length(test_parameters))
  colnames(group_params) <- test_parameters
  rownames(group_params) <- group_levels

  # Store starting values for each group (for bootstrap efficiency)
  group_start_values <- list()

  # Store first group results
  group_params[1, ] <- test_params[test_parameters]

  # Extract starting values from first group for bootstrap
  if (!is.null(sex)) {
    # For sex models, we'll use a combined approach - average the sex-specific parameters
    group_start_values[[group_levels[1]]] <- list(
      Linf = mean(c(test_params[paste0("Linf_", levels(sex))]), na.rm = TRUE),
      k = mean(c(test_params[paste0("k_", levels(sex))]), na.rm = TRUE),
      t0 = mean(c(test_params[paste0("t0_", levels(sex))]), na.rm = TRUE),
      cv = mean(c(test_params[paste0("CV_", levels(sex))]), na.rm = TRUE)
    )
  } else {
    # For single models, use parameters directly
    group_start_values[[group_levels[1]]] <- list(
      Linf = test_params[["Linf"]],
      k = test_params[["k"]],
      t0 = test_params[["t0"]],
      cv = test_params[["CV"]]
    )
  }

  # Fit remaining groups
  for (i in 2:length(group_levels)) {
    group_mask <- group == group_levels[i]
    group_age_i <- age[group_mask]
    group_length_i <- length[group_mask]
    group_sex_i <- if (!is.null(sex)) sex[group_mask] else NULL

    if (length(group_age_i) >= 10) { # Minimum sample size check
      params_i <- fit_group_model(group_age_i, group_length_i, group_sex_i)
      if (!is.null(params_i)) {
        group_params[i, ] <- params_i[test_parameters]

        # Store starting values for bootstrap
        if (!is.null(sex)) {
          # For sex models, average the sex-specific parameters for starting values
          group_start_values[[group_levels[i]]] <- list(
            Linf = mean(c(params_i[paste0("Linf_", levels(sex))]), na.rm = TRUE),
            k = mean(c(params_i[paste0("k_", levels(sex))]), na.rm = TRUE),
            t0 = mean(c(params_i[paste0("t0_", levels(sex))]), na.rm = TRUE),
            cv = mean(c(params_i[paste0("CV_", levels(sex))]), na.rm = TRUE)
          )
        } else {
          # For single models, use parameters directly
          group_start_values[[group_levels[i]]] <- list(
            Linf = params_i[["Linf"]],
            k = params_i[["k"]],
            t0 = params_i[["t0"]],
            cv = params_i[["CV"]]
          )
        }
      }
    } else {
      warning(paste("Group", group_levels[i], "has fewer than 10 observations, skipping"))
    }
  }

  # Calculate observed differences
  observed_diffs <- calc_max_diff(group_params)
  observed_diffs <- observed_diffs[test_parameters]

  if (verbose) {
    cat("Observed parameter differences:\n")
    print(observed_diffs)
    cat("\nStarting bootstrap permutation test with", n_bootstrap, "iterations...\n")
    if (age_stratified) {
      cat("Using age-stratified permutation with", age_bin_width, "year age bins\n")
    }
  }

  # Prepare age bins for stratified permutation
  if (age_stratified) {
    # Create age bins based on bin width rather than number of bins
    min_age <- min(age)
    max_age <- max(age)
    age_breaks <- seq(from = min_age, to = max_age + age_bin_width, by = age_bin_width)
    age_bins <- cut(age, breaks = age_breaks, include.lowest = TRUE, right = FALSE)

    # Calculate actual number of bins created
    n_bins_created <- length(levels(age_bins))

    if (verbose) {
      cat("Age range:", round(min_age, 1), "to", round(max_age, 1), "\n")
      cat("Bin width:", age_bin_width, "years,", n_bins_created, "bins created\n")
      cat("Age bin sizes:", table(age_bins), "\n")
    }
  }

  # Bootstrap permutation test
  null_diffs <- matrix(NA, nrow = n_bootstrap, ncol = length(test_parameters))
  colnames(null_diffs) <- test_parameters

  # Progress reporting
  progress_points <- seq(0, n_bootstrap, by = max(1, n_bootstrap %/% 10))

  for (b in 1:n_bootstrap) {
    # Permute group labels (age-stratified or simple)
    if (age_stratified) {
      # Age-stratified permutation: permute within each age bin
      perm_group <- group # Start with original
      for (bin_level in levels(age_bins)) {
        bin_indices <- which(age_bins == bin_level)
        if (length(bin_indices) > 1) {
          # Permute group labels within this age bin
          perm_group[bin_indices] <- sample(group[bin_indices])
        }
      }
    } else {
      # Simple random permutation
      perm_group <- sample(group)
    }

    # Fit models to permuted groups using observed parameters as starting values
    perm_params <- matrix(NA, nrow = length(group_levels), ncol = length(test_parameters))
    colnames(perm_params) <- test_parameters

    for (i in seq_along(group_levels)) {
      group_mask <- perm_group == group_levels[i]
      group_age_i <- age[group_mask]
      group_length_i <- length[group_mask]
      group_sex_i <- if (!is.null(sex)) sex[group_mask] else NULL

      if (length(group_age_i) >= 10) {
        # Use starting values from the observed fit for this group (if available)
        start_vals <- group_start_values[[group_levels[i]]]
        params_i <- fit_group_model(group_age_i, group_length_i, group_sex_i, start_vals)
        if (!is.null(params_i)) {
          perm_params[i, ] <- params_i[test_parameters]
        }
      }
    }

    # Calculate differences for this permutation
    perm_diffs <- calc_max_diff(perm_params)
    null_diffs[b, ] <- perm_diffs[test_parameters]

    # Progress reporting
    if (verbose && b %in% progress_points) {
      cat("Completed", b, "of", n_bootstrap, "permutations\n")
    }
  }

  # Calculate p-values
  p_values <- numeric(length(test_parameters))
  names(p_values) <- test_parameters

  for (p in test_parameters) {
    if (!is.na(observed_diffs[p])) {
      # Two-tailed test: proportion of permuted differences >= observed difference
      p_values[p] <- sum(null_diffs[, p] >= observed_diffs[p], na.rm = TRUE) /
        sum(!is.na(null_diffs[, p]))
    } else {
      p_values[p] <- NA
    }
  }

  # Determine significance
  significant <- p_values < alpha

  if (verbose) {
    cat("\nResults:\n")
    for (p in test_parameters) {
      if (!is.na(p_values[p])) {
        cat(sprintf(
          "%s: p = %.4f %s\n", p, p_values[p],
          ifelse(significant[p], "*", "")
        ))
      } else {
        cat(sprintf("%s: p = NA (fitting failed)\n", p))
      }
    }
    cat("\n* indicates significance at alpha =", alpha, "\n")
  }

  # Curve comparison test
  curve_results <- NULL
  if (test_curves) {
    if (verbose) cat("\nTesting growth curve differences...\n")
    
    # Define evaluation ages if not provided
    if (is.null(curve_ages)) {
      curve_ages <- seq(from = min(age), to = max(age), by = 0.5)
    }
    
    if (verbose) {
      cat("Evaluating curves at", length(curve_ages), "age points from", 
          round(min(curve_ages), 1), "to", round(max(curve_ages), 1), "\n")
    }
    
    # Calculate observed curve deviance
    sex_levels_for_curves <- if (!is.null(sex)) levels(sex) else NULL
    observed_curve_deviance <- calc_curve_deviance(group_params, curve_ages, sex_levels_for_curves)
    
    if (verbose) {
      if (!is.null(sex)) {
        cat("Observed curve deviance:\n")
        cat("  Overall maximum:", round(observed_curve_deviance$overall, 3), "\n")
        for (sex_level in names(observed_curve_deviance$by_sex)) {
          cat("  ", sex_level, ":", round(observed_curve_deviance$by_sex[[sex_level]], 3), "\n")
        }
      } else {
        cat("Observed curve deviance:", round(observed_curve_deviance$overall, 3), "\n")
      }
    }
    
    # Bootstrap curve deviances using the same permutation logic
    null_curve_deviances <- numeric(n_bootstrap)
    if (!is.null(sex)) {
      null_curve_deviances_by_sex <- matrix(NA, nrow = n_bootstrap, ncol = length(sex_levels_for_curves))
      colnames(null_curve_deviances_by_sex) <- sex_levels_for_curves
    }
    
    if (verbose) cat("Bootstrap testing curve deviances...\n")
    
    # Use the same permutation results from the parameter test
    for (b in 1:n_bootstrap) {
      # Permute group labels (same logic as parameter test)
      if (age_stratified) {
        perm_group <- group
        for (bin_level in levels(age_bins)) {
          bin_indices <- which(age_bins == bin_level)
          if (length(bin_indices) > 1) {
            perm_group[bin_indices] <- sample(group[bin_indices])
          }
        }
      } else {
        perm_group <- sample(group)
      }
      
      # Fit models to permuted groups for curve analysis
      perm_params_curves <- matrix(NA, nrow = length(group_levels), ncol = length(test_parameters))
      colnames(perm_params_curves) <- test_parameters
      rownames(perm_params_curves) <- group_levels
      
      for (i in seq_along(group_levels)) {
        group_mask <- perm_group == group_levels[i]
        group_age_i <- age[group_mask]
        group_length_i <- length[group_mask]
        group_sex_i <- if (!is.null(sex)) sex[group_mask] else NULL
        
        if (length(group_age_i) >= 10) {
          start_vals <- group_start_values[[group_levels[i]]]
          params_i <- fit_group_model(group_age_i, group_length_i, group_sex_i, start_vals)
          if (!is.null(params_i)) {
            perm_params_curves[i, ] <- params_i[test_parameters]
          }
        }
      }
      
      # Calculate curve deviance for this permutation
      perm_curve_deviance <- calc_curve_deviance(perm_params_curves, curve_ages, sex_levels_for_curves)
      null_curve_deviances[b] <- perm_curve_deviance$overall
      
      if (!is.null(sex)) {
        for (sex_level in sex_levels_for_curves) {
          null_curve_deviances_by_sex[b, sex_level] <- perm_curve_deviance$by_sex[[sex_level]]
        }
      }
    }
    
    # Calculate p-values for curve tests
    curve_p_value <- sum(null_curve_deviances >= observed_curve_deviance$overall, na.rm = TRUE) / 
                     sum(!is.na(null_curve_deviances))
    
    curve_p_values_by_sex <- NULL
    if (!is.null(sex)) {
      curve_p_values_by_sex <- numeric(length(sex_levels_for_curves))
      names(curve_p_values_by_sex) <- sex_levels_for_curves
      for (sex_level in sex_levels_for_curves) {
        curve_p_values_by_sex[sex_level] <- 
          sum(null_curve_deviances_by_sex[, sex_level] >= observed_curve_deviance$by_sex[[sex_level]], na.rm = TRUE) /
          sum(!is.na(null_curve_deviances_by_sex[, sex_level]))
      }
    }
    
    # Determine significance
    curve_significant <- curve_p_value < alpha
    curve_significant_by_sex <- NULL
    if (!is.null(sex)) {
      curve_significant_by_sex <- curve_p_values_by_sex < alpha
    }
    
    if (verbose) {
      cat("\nCurve comparison results:\n")
      cat(sprintf("Overall curve deviance: p = %.4f %s\n", 
                 curve_p_value, ifelse(curve_significant, "*", "")))
      if (!is.null(sex)) {
        for (sex_level in names(curve_p_values_by_sex)) {
          cat(sprintf("%s curve deviance: p = %.4f %s\n", 
                     sex_level, curve_p_values_by_sex[sex_level], 
                     ifelse(curve_significant_by_sex[sex_level], "*", "")))
        }
      }
    }
    
    # Store curve results
    curve_results <- list(
      observed_deviance = observed_curve_deviance,
      p_value = curve_p_value,
      significant = curve_significant,
      null_deviances = null_curve_deviances,
      evaluation_ages = curve_ages
    )
    
    if (!is.null(sex)) {
      curve_results$p_values_by_sex <- curve_p_values_by_sex
      curve_results$significant_by_sex <- curve_significant_by_sex
      curve_results$null_deviances_by_sex <- null_curve_deviances_by_sex
    }
  }

  # Prepare results
  result <- list(
    observed_diffs = observed_diffs,
    p_values = p_values,
    significant = significant,
    group_parameters = group_params,
    null_distributions = null_diffs,
    curve_comparison = curve_results,
    method_info = list(
      n_bootstrap = n_bootstrap,
      alpha = alpha,
      parameters_tested = test_parameters,
      original_parameters = parameters,
      has_sex = !is.null(sex),
      sex_levels = if (!is.null(sex)) levels(sex) else NULL,
      n_groups = length(group_levels),
      group_names = group_levels,
      sample_sizes = as.numeric(table(group)),
      total_n = length(age),
      age_stratified = age_stratified,
      age_bin_width = if (age_stratified) age_bin_width else NULL,
      age_range = c(min(age), max(age)),
      test_curves = test_curves,
      curve_ages_range = if (test_curves && !is.null(curve_ages)) c(min(curve_ages), max(curve_ages)) else NULL
    )
  )

  class(result) <- "vb_comparison"
  return(result)
}
