#' Compare Von Bertalanffy Growth Parameters Between Groups Using Bootstrap Permutation Test
#'
#' This function performs a bootstrap permutation test to evaluate whether von Bertalanffy
#' growth parameters differ significantly between two or more groups. The test compares
#' the observed differences in parameters against a null distribution generated by
#' randomly permuting group labels.
#'
#' @param age A numeric vector of ages
#' @param length A numeric vector of lengths
#' @param group A factor or character vector specifying the group for each observation
#' @param sex Optional factor or character vector specifying sex for each observation (for sex-specific models)
#' @param n_bootstrap Number of bootstrap permutations (default 1000)
#' @param parameters Character vector of parameters to test. Options: "Linf", "k", "t0", "CV" (default all).
#'   For sex models, parameters are automatically expanded to sex-specific versions (e.g., "Linf_M", "Linf_F")
#' @param alpha Significance level for the test (default 0.05)
#' @param verbose Logical, whether to print progress messages (default TRUE)
#' @param seed Optional seed for reproducible results
#' @param min_obs Minimum number of observations required per sex/group combination (default 50).
#'   Combinations with fewer observations will be removed before analysis
#' @param age_stratified Logical, whether to use age-stratified permutation (default TRUE).
#'   When TRUE, permutations are performed within age bins to maintain age distribution
#' @param age_bin_width Width of age bins in years for stratified permutation (default 2).
#'   Only used when age_stratified = TRUE. Each bin will span this many years.
#' @param test_curves Logical, whether to test for differences in growth curves (default TRUE).
#'   This performs a permutation test on the deviance between fitted curves
#' @param curve_ages Optional numeric vector of ages at which to evaluate curves for comparison.
#'   If NULL, uses a sequence from min to max age with 1 year increments
#' @param curve_method Method for calculating curve deviance (default "max_abs"). Options:
#'   \itemize{
#'     \item "max_abs": Maximum absolute difference between curves
#'     \item "rmse": Root mean square error between curves (more robust to outliers)
#'     \item "area": Area between curves (biologically meaningful total difference)
#'     \item "weighted": Weighted deviance (higher weight for younger ages)
#'     \item "integrated": Trapezoidal integration of absolute differences
#'   }
#'
#' @return A list containing:
#' \itemize{
#'   \item \code{observed_diffs}: Observed differences between groups for each parameter
#'   \item \code{p_values}: P-values for each parameter comparison
#'   \item \code{significant}: Logical indicating which parameters show significant differences
#'   \item \code{group_parameters}: Parameter estimates for each group
#'   \item \code{null_distributions}: Bootstrap null distributions for each parameter
#'   \item \code{curve_comparison}: Results from growth curve comparison test (if test_curves = TRUE)
#'   \item \code{method_info}: Information about the test method and settings
#' }
#'
#' @details
#' The function fits separate von Bertalanffy models to each group, then performs
#' a bootstrap permutation test by:
#' \enumerate{
#'   \item Computing observed parameter differences between groups
#'   \item Randomly permuting group labels n_bootstrap times (with optional age stratification)
#'   \item Fitting models to each permuted dataset
#'   \item Computing both parameter differences and growth curve deviances for each permutation
#'   \item Calculating p-values as the proportion of permuted differences
#'       that exceed the observed differences
#' }
#'
#' The bootstrap permutation is performed efficiently in a single loop that computes
#' both parameter comparisons and growth curve comparisons (if enabled) from the same
#' fitted models, avoiding redundant computation.
#'
# When \code{age_stratified = TRUE} (default), permutations are performed within
#' age bins to ensure that age distributions remain comparable between groups.
#' This is crucial for validity as it tests differences in growth parameters
#' rather than differences in age distribution. Age bins are created using
#' \code{age_bin_width} to define the width of each bin in years.
#'
#' For multiple groups, the test statistic is the maximum pairwise difference
#' between any two groups for each parameter.
#'
#' @examples
#' \dontrun{
#' # Simulate data for two groups with different growth parameters
#' set.seed(123)
#' n_per_group <- 50
#' age1 <- runif(n_per_group, 1, 15)
#' age2 <- runif(n_per_group, 1, 15)
#'
#' # Group 1: Linf=100, k=0.2
#' length1 <- 100 * (1 - exp(-0.2 * (age1 - (-0.5)))) + rnorm(n_per_group, 0, 8)
#' # Group 2: Linf=120, k=0.15 (different parameters)
#' length2 <- 120 * (1 - exp(-0.15 * (age2 - (-0.5)))) + rnorm(n_per_group, 0, 10)
#'
#' age <- c(age1, age2)
#' length <- c(length1, length2)
#' group <- rep(c("Population_A", "Population_B"), each = n_per_group)
#'
#' # Test for differences in basic parameters
#' result <- compare_vb_mle(
#'   age = age, length = length, group = group,
#'   n_bootstrap = 500, seed = 123
#' )
#'
#' # Test with sex-specific models
#' sex <- rep(c("M", "F"), length.out = length(age))
#' result_sex <- compare_vb_mle(
#'   age = age, length = length, group = group, sex = sex,
#'   n_bootstrap = 500, seed = 123
#' )
#'
#' # Test with different curve comparison methods
#' result_rmse <- compare_vb_mle(
#'   age = age, length = length, group = group,
#'   curve_method = "rmse", n_bootstrap = 500, seed = 123
#' )
#'
#' result_area <- compare_vb_mle(
#'   age = age, length = length, group = group,
#'   curve_method = "area", n_bootstrap = 500, seed = 123
#' )
#'
#' # View results
#' print(result$p_values)
#' print(result$significant)
#' print(result$group_parameters)
#' }
#'
#' @export
compare_vb_mle <- function(age, length, group, sex = NULL, n_bootstrap = 1000,
                           parameters = c("Linf", "k", "t0", "CV"),
                           alpha = 0.05, verbose = TRUE, seed = NULL, min_obs = 50,
                           age_stratified = TRUE, age_bin_width = 2,
                           test_curves = TRUE, curve_ages = NULL,
                           curve_method = "max_abs") {
  # Set seed for reproducibility if provided
  if (!is.null(seed)) {
    set.seed(seed)
  }

  # Input validation
  if (length(age) != length(length) || length(age) != length(group)) {
    stop("age, length, and group must have the same length")
  }

  if (!is.null(sex) && length(sex) != length(age)) {
    stop("sex must have the same length as age, length, and group")
  }

  # Validate curve method
  valid_curve_methods <- c("max_abs", "rmse", "area", "weighted", "integrated")
  if (!curve_method %in% valid_curve_methods) {
    stop("curve_method must be one of: ", paste(valid_curve_methods, collapse = ", "))
  }

  # Remove missing values
  if (is.null(sex)) {
    complete_cases <- complete.cases(age, length, group)
    age <- age[complete_cases]
    length <- length[complete_cases]
    group <- as.factor(group)[complete_cases]
    sex <- NULL
  } else {
    complete_cases <- complete.cases(age, length, group, sex)
    age <- age[complete_cases]
    length <- length[complete_cases]
    group <- as.factor(group)[complete_cases]
    sex <- as.factor(sex)[complete_cases]
  }

  if (verbose) {
    cat("Removed", sum(!complete_cases), "incomplete cases\n")
    cat("Analysing", length(age), "observations\n")
  }

  # Filter out sex/group combinations with insufficient observations
  if (!is.null(sex) && min_obs > 0) {
    # Create sex/group combinations
    sex_group_combo <- interaction(sex, group, drop = TRUE)
    combo_counts <- table(sex_group_combo)

    # Identify combinations with sufficient observations
    sufficient_combos <- names(combo_counts)[combo_counts >= min_obs]

    if (length(sufficient_combos) == 0) {
      stop("No sex/group combinations have >= ", min_obs, " observations")
    }

    # Filter to keep only sufficient combinations
    keep_indices <- sex_group_combo %in% sufficient_combos

    if (sum(!keep_indices) > 0) {
      insufficient_combos <- names(combo_counts)[combo_counts < min_obs]
      if (verbose) {
        cat(
          "Removed", sum(!keep_indices), "observations from", length(insufficient_combos),
          "sex/group combinations with < ", min_obs, " observations:\n"
        )
        for (combo in insufficient_combos) {
          cat("  ", combo, ": ", combo_counts[combo], " observations\n", sep = "")
        }
      }

      age <- age[keep_indices]
      length <- length[keep_indices]
      group <- droplevels(group[keep_indices])
      sex <- droplevels(sex[keep_indices])

      if (verbose) {
        cat("Remaining", length(age), "observations for analysis\n")
      }
    }
  } else if (is.null(sex) && min_obs > 0) {
    # For non-sex models, filter groups with insufficient observations
    group_counts <- table(group)
    sufficient_groups <- names(group_counts)[group_counts >= min_obs]

    if (length(sufficient_groups) == 0) {
      stop("No groups have >= ", min_obs, " observations")
    }

    keep_indices <- group %in% sufficient_groups

    if (sum(!keep_indices) > 0) {
      insufficient_groups <- names(group_counts)[group_counts < min_obs]
      if (verbose) {
        cat(
          "Removed", sum(!keep_indices), "observations from", length(insufficient_groups),
          "groups with < ", min_obs, " observations:\n"
        )
        for (grp in insufficient_groups) {
          cat("  ", grp, ": ", group_counts[grp], " observations\n", sep = "")
        }
      }

      age <- age[keep_indices]
      length <- length[keep_indices]
      group <- droplevels(group[keep_indices])

      if (verbose) {
        cat("Remaining", length(age), "observations for analysis\n")
      }
    }
  }

  # Check we have at least 2 groups
  group_levels <- levels(group)
  if (length(group_levels) < 2) {
    stop("Need at least 2 groups for comparison")
  }

  if (verbose) {
    cat("Comparing", length(group_levels), "groups:", paste(group_levels, collapse = ", "), "\n")
    cat("Group sizes:", table(group), "\n")
  }

  # Validate parameters
  valid_params <- c("Linf", "k", "t0", "CV")
  if (!all(parameters %in% valid_params)) {
    stop("parameters must be a subset of: ", paste(valid_params, collapse = ", "))
  }

  # Helper function to extract parameters from model fit
  extract_parameters <- function(fit) {
    if (!is.null(fit$models)) {
      # Sex-specific models - parameters are in fit$models$sex$parameters
      params <- list()
      for (sex_level in names(fit$models)) {
        sex_model <- fit$models[[sex_level]]
        sex_params <- sex_model$parameters
        for (param in c("Linf", "k", "t0", "cv")) {
          param_name <- paste0(toupper(substring(param, 1, 1)), substring(param, 2), "_", sex_level)
          if (param == "cv") param_name <- paste0("CV_", sex_level)
          params[[param_name]] <- sex_params[[param]]
        }
      }
      return(unlist(params))
    } else {
      # Single model - parameters is a matrix with rownames and "estimate" column
      params <- fit$parameters
      result <- c(
        Linf = params["Linf", "estimate"],
        k = params["k", "estimate"],
        t0 = params["t0", "estimate"],
        CV = params["cv", "estimate"] # Note: lowercase "cv" in row, uppercase "CV" in result
      )
      return(result)
    }
  }

  # Function to fit VB model to a group and extract parameters
  fit_group_model <- function(group_age, group_length, group_sex = NULL, start_vals = NULL) {
    tryCatch(
      {
        # Load the fit_vb_mle function (assuming it's available)
        if (!exists("fit_vb_mle")) {
          stop("fit_vb_mle function not found. Please load the growthVB package.")
        }

        fit <- fit_vb_mle(age = group_age, length = group_length, sex = group_sex, start_values = start_vals)
        return(extract_parameters(fit))
      },
      error = function(e) {
        warning(paste("Failed to fit model:", e$message))
        return(NULL)
      }
    )
  }

  # Function to calculate maximum pairwise difference for each parameter
  calc_max_diff <- function(param_matrix) {
    n_groups <- nrow(param_matrix)
    max_diffs <- numeric(ncol(param_matrix))
    names(max_diffs) <- colnames(param_matrix)

    for (p in 1:ncol(param_matrix)) {
      param_vals <- param_matrix[, p]
      if (all(!is.na(param_vals))) {
        max_diffs[p] <- max(param_vals) - min(param_vals)
      } else {
        max_diffs[p] <- NA
      }
    }
    return(max_diffs)
  }

  # Function to calculate von Bertalanffy curve
  vb_curve <- function(age, Linf, k, t0) {
    Linf * (1 - exp(-k * (age - t0)))
  }

  # Function to extract curve parameters from fitted parameters
  extract_curve_params <- function(params, sex_level = NULL) {
    if (!is.null(sex_level)) {
      # Sex-specific parameters
      Linf <- params[[paste0("Linf_", sex_level)]]
      k <- params[[paste0("k_", sex_level)]]
      t0 <- params[[paste0("t0_", sex_level)]]
    } else {
      # Single model parameters
      Linf <- params[["Linf"]]
      k <- params[["k"]]
      t0 <- params[["t0"]]
    }
    return(list(Linf = Linf, k = k, t0 = t0))
  }

  # Function to calculate maximum curve deviance between groups
  calc_curve_deviance <- function(group_params, eval_ages, sex_levels = NULL, method = "max_abs") {
    n_groups <- nrow(group_params)
    group_names <- rownames(group_params)

    if (!is.null(sex_levels)) {
      # Sex-specific models: calculate deviance for each sex separately, then take maximum
      max_deviance_overall <- 0
      deviance_by_sex <- list()

      for (sex_level in sex_levels) {
        # Calculate curves for each group for this sex
        group_curves <- matrix(NA, nrow = n_groups, ncol = length(eval_ages))
        rownames(group_curves) <- group_names

        for (i in 1:n_groups) {
          curve_params <- extract_curve_params(group_params[i, ], sex_level)
          if (!any(is.na(unlist(curve_params)))) {
            group_curves[i, ] <- vb_curve(
              eval_ages, curve_params$Linf,
              curve_params$k, curve_params$t0
            )
          }
        }

        # Calculate deviance using specified method for this sex
        max_deviance_sex <- calc_pairwise_deviance(group_curves, eval_ages, method)
        deviance_by_sex[[sex_level]] <- max_deviance_sex
        max_deviance_overall <- max(max_deviance_overall, max_deviance_sex)
      }

      return(list(overall = max_deviance_overall, by_sex = deviance_by_sex))
    } else {
      # Single model: calculate curves for each group
      group_curves <- matrix(NA, nrow = n_groups, ncol = length(eval_ages))
      rownames(group_curves) <- group_names

      for (i in 1:n_groups) {
        curve_params <- extract_curve_params(group_params[i, ])
        if (!any(is.na(unlist(curve_params)))) {
          group_curves[i, ] <- vb_curve(
            eval_ages, curve_params$Linf,
            curve_params$k, curve_params$t0
          )
        }
      }

      # Calculate maximum pairwise deviance using specified method
      max_deviance <- calc_pairwise_deviance(group_curves, eval_ages, method)
      return(list(overall = max_deviance))
    }
  }

  # Helper function to calculate pairwise deviances between curves
  calc_pairwise_deviance <- function(group_curves, eval_ages, method = "max_abs") {
    n_groups <- nrow(group_curves)
    max_deviance <- 0

    if (sum(complete.cases(group_curves)) >= 2) {
      for (i in 1:(n_groups - 1)) {
        for (j in (i + 1):n_groups) {
          if (!any(is.na(group_curves[i, ])) && !any(is.na(group_curves[j, ]))) {
            curve1 <- group_curves[i, ]
            curve2 <- group_curves[j, ]

            # Calculate deviance based on method
            deviance_ij <- switch(method,
              "max_abs" = max(abs(curve1 - curve2)),
              "rmse" = sqrt(mean((curve1 - curve2)^2)),
              "area" = {
                age_increment <- if (length(eval_ages) > 1) mean(diff(eval_ages)) else 1
                sum(abs(curve1 - curve2)) * age_increment
              },
              "weighted" = {
                # Weight by inverse age (more importance to early growth)
                weights <- 1 / pmax(eval_ages, 0.5) # Avoid division by zero
                sum(weights * abs(curve1 - curve2)) / sum(weights)
              },
              "integrated" = {
                # Trapezoidal integration of absolute differences
                if (length(eval_ages) > 1) {
                  abs_diff <- abs(curve1 - curve2)
                  # Trapezoidal rule
                  sum(diff(eval_ages) * (abs_diff[-1] + abs_diff[-length(abs_diff)]) / 2)
                } else {
                  abs(curve1 - curve2)
                }
              },
              max(abs(curve1 - curve2)) # Default to max_abs
            )

            max_deviance <- max(max_deviance, deviance_ij)
          }
        }
      }
    }

    return(max_deviance)
  }

  # Fit models to each group and get observed parameters
  if (verbose) cat("Fitting models to each group...\n")

  # First fit to determine parameter structure
  group_mask <- group == group_levels[1]
  group_age_test <- age[group_mask]
  group_length_test <- length[group_mask]
  group_sex_test <- if (!is.null(sex)) sex[group_mask] else NULL

  test_params <- fit_group_model(group_age_test, group_length_test, group_sex_test)
  if (is.null(test_params)) {
    stop("Failed to fit initial model to determine parameter structure")
  }

  # Determine which parameters to test based on model type
  available_params <- names(test_params)
  if (!is.null(sex)) {
    # For sex models, expand parameters to sex-specific versions
    test_parameters <- character(0)
    sex_levels <- levels(sex)
    for (param in parameters) {
      for (sex_level in sex_levels) {
        # Match the naming convention used in extract_parameters
        if (param == "CV") {
          param_name <- paste0("CV_", sex_level)
        } else {
          param_name <- paste0(toupper(substring(param, 1, 1)), substring(param, 2), "_", sex_level)
        }
        if (param_name %in% available_params) {
          test_parameters <- c(test_parameters, param_name)
        }
      }
    }
  } else {
    # For single models, use parameters as-is
    test_parameters <- intersect(parameters, available_params)
  }

  if (length(test_parameters) == 0) {
    stop("No valid parameters found for testing")
  }

  if (verbose) {
    cat("Testing parameters:", paste(test_parameters, collapse = ", "), "\n")
  }

  # Initialize parameter matrix and starting values storage
  group_params <- matrix(NA, nrow = length(group_levels), ncol = length(test_parameters))
  colnames(group_params) <- test_parameters
  rownames(group_params) <- group_levels

  # Store starting values for each group (for bootstrap efficiency)
  group_start_values <- list()

  # Store first group results
  group_params[1, ] <- test_params[test_parameters]

  # Extract starting values from first group for bootstrap
  if (!is.null(sex)) {
    # For sex models, we'll use a combined approach - average the sex-specific parameters
    group_start_values[[group_levels[1]]] <- list(
      Linf = mean(c(test_params[paste0("Linf_", levels(sex))]), na.rm = TRUE),
      k = mean(c(test_params[paste0("k_", levels(sex))]), na.rm = TRUE),
      t0 = mean(c(test_params[paste0("t0_", levels(sex))]), na.rm = TRUE),
      cv = mean(c(test_params[paste0("CV_", levels(sex))]), na.rm = TRUE)
    )
  } else {
    # For single models, use parameters directly
    group_start_values[[group_levels[1]]] <- list(
      Linf = test_params[["Linf"]],
      k = test_params[["k"]],
      t0 = test_params[["t0"]],
      cv = test_params[["CV"]]
    )
  }

  # Fit remaining groups
  for (i in 2:length(group_levels)) {
    group_mask <- group == group_levels[i]
    group_age_i <- age[group_mask]
    group_length_i <- length[group_mask]
    group_sex_i <- if (!is.null(sex)) sex[group_mask] else NULL

    if (length(group_age_i) >= 10) { # Minimum sample size check
      params_i <- fit_group_model(group_age_i, group_length_i, group_sex_i)
      if (!is.null(params_i)) {
        group_params[i, ] <- params_i[test_parameters]

        # Store starting values for bootstrap
        if (!is.null(sex)) {
          # For sex models, average the sex-specific parameters for starting values
          group_start_values[[group_levels[i]]] <- list(
            Linf = mean(c(params_i[paste0("Linf_", levels(sex))]), na.rm = TRUE),
            k = mean(c(params_i[paste0("k_", levels(sex))]), na.rm = TRUE),
            t0 = mean(c(params_i[paste0("t0_", levels(sex))]), na.rm = TRUE),
            cv = mean(c(params_i[paste0("CV_", levels(sex))]), na.rm = TRUE)
          )
        } else {
          # For single models, use parameters directly
          group_start_values[[group_levels[i]]] <- list(
            Linf = params_i[["Linf"]],
            k = params_i[["k"]],
            t0 = params_i[["t0"]],
            cv = params_i[["CV"]]
          )
        }
      }
    } else {
      warning(paste("Group", group_levels[i], "has fewer than 10 observations, skipping"))
    }
  }

  # Calculate observed differences
  observed_diffs <- calc_max_diff(group_params)
  observed_diffs <- observed_diffs[test_parameters]

  if (verbose) {
    cat("Observed parameter differences:\n")
    print(observed_diffs)
    cat("\nStarting bootstrap permutation test with", n_bootstrap, "iterations...\n")
    if (age_stratified) {
      cat("Using age-stratified permutation with", age_bin_width, "year age bins\n")
    }
    if (test_curves) {
      cat("Testing both parameters and growth curves in single bootstrap loop\n")
      cat("Curve comparison method:", curve_method, "\n")
    }
  }

  # Prepare age bins for stratified permutation
  if (age_stratified) {
    # Create age bins based on bin width rather than number of bins
    min_age <- min(age)
    max_age <- max(age)
    age_breaks <- seq(from = min_age, to = max_age + age_bin_width, by = age_bin_width)
    age_bins <- cut(age, breaks = age_breaks, include.lowest = TRUE, right = FALSE)

    # Calculate actual number of bins created
    n_bins_created <- length(levels(age_bins))

    if (verbose) {
      cat("Age range:", round(min_age, 1), "to", round(max_age, 1), "\n")
      cat("Bin width:", age_bin_width, "years,", n_bins_created, "bins created\n")
      cat("Age bin sizes:", table(age_bins), "\n")
    }
  }

  # Prepare curve evaluation ages if curve testing is enabled
  sex_levels_for_curves <- if (!is.null(sex)) levels(sex) else NULL
  if (test_curves) {
    if (is.null(curve_ages)) {
      curve_ages <- seq(from = min(age), to = max(age), by = 1)
    }
  }

  # Bootstrap permutation test (combined for both parameters and curves)
  null_diffs <- matrix(NA, nrow = n_bootstrap, ncol = length(test_parameters))
  colnames(null_diffs) <- test_parameters

  # Initialize curve deviance storage if testing curves
  null_curve_deviances <- if (test_curves) numeric(n_bootstrap) else NULL
  null_curve_deviances_by_sex <- if (test_curves && !is.null(sex)) {
    matrix(NA, nrow = n_bootstrap, ncol = length(sex_levels_for_curves))
  } else {
    NULL
  }
  if (!is.null(null_curve_deviances_by_sex)) {
    colnames(null_curve_deviances_by_sex) <- sex_levels_for_curves
  }

  # Progress reporting
  progress_points <- seq(0, n_bootstrap, by = max(1, n_bootstrap %/% 10))

  for (b in 1:n_bootstrap) {
    # Permute group labels (age-stratified or simple)
    if (age_stratified) {
      # Age-stratified permutation: permute within each age bin
      perm_group <- group # Start with original
      for (bin_level in levels(age_bins)) {
        bin_indices <- which(age_bins == bin_level)
        if (length(bin_indices) > 1) {
          # Permute group labels within this age bin
          perm_group[bin_indices] <- sample(group[bin_indices])
        }
      }
    } else {
      # Simple random permutation
      perm_group <- sample(group)
    }

    # Fit models to permuted groups using observed parameters as starting values
    perm_params <- matrix(NA, nrow = length(group_levels), ncol = length(test_parameters))
    colnames(perm_params) <- test_parameters
    rownames(perm_params) <- group_levels

    for (i in seq_along(group_levels)) {
      group_mask <- perm_group == group_levels[i]
      group_age_i <- age[group_mask]
      group_length_i <- length[group_mask]
      group_sex_i <- if (!is.null(sex)) sex[group_mask] else NULL

      if (length(group_age_i) >= 10) {
        # Use starting values from the observed fit for this group (if available)
        start_vals <- group_start_values[[group_levels[i]]]
        params_i <- fit_group_model(group_age_i, group_length_i, group_sex_i, start_vals)
        if (!is.null(params_i)) {
          perm_params[i, ] <- params_i[test_parameters]
        }
      }
    }

    # Calculate parameter differences for this permutation
    perm_diffs <- calc_max_diff(perm_params)
    null_diffs[b, ] <- perm_diffs[test_parameters]

    # Calculate curve deviances for this permutation (if testing curves)
    if (test_curves) {
      perm_curve_deviance <- calc_curve_deviance(perm_params, curve_ages, sex_levels_for_curves, curve_method)
      null_curve_deviances[b] <- perm_curve_deviance$overall

      if (!is.null(sex)) {
        for (sex_level in sex_levels_for_curves) {
          null_curve_deviances_by_sex[b, sex_level] <- perm_curve_deviance$by_sex[[sex_level]]
        }
      }
    }

    # Progress reporting
    if (verbose && b %in% progress_points) {
      cat("Completed", b, "of", n_bootstrap, "permutations\n")
    }
  }

  # Calculate p-values
  p_values <- numeric(length(test_parameters))
  names(p_values) <- test_parameters

  for (p in test_parameters) {
    if (!is.na(observed_diffs[p])) {
      # Two-tailed test: proportion of permuted differences >= observed difference
      p_values[p] <- sum(null_diffs[, p] >= observed_diffs[p], na.rm = TRUE) /
        sum(!is.na(null_diffs[, p]))
    } else {
      p_values[p] <- NA
    }
  }

  # Determine significance
  significant <- p_values < alpha

  if (verbose) {
    cat("\nResults:\n")
    for (p in test_parameters) {
      if (!is.na(p_values[p])) {
        cat(sprintf(
          "%s: p = %.4f %s\n", p, p_values[p],
          ifelse(significant[p], "*", "")
        ))
      } else {
        cat(sprintf("%s: p = NA (fitting failed)\n", p))
      }
    }
    cat("\n* indicates significance at alpha =", alpha, "\n")
  }

  # Curve comparison test
  curve_results <- NULL
  if (test_curves) {
    if (verbose) cat("\nTesting growth curve differences...\n")

    if (verbose) {
      cat(
        "Evaluating curves at", length(curve_ages), "age points from",
        round(min(curve_ages), 1), "to", round(max(curve_ages), 1), "\n"
      )
    }

    # Calculate observed curve deviance
    observed_curve_deviance <- calc_curve_deviance(group_params, curve_ages, sex_levels_for_curves, curve_method)

    if (verbose) {
      if (!is.null(sex)) {
        cat("Observed curve deviance (", curve_method, "):\n", sep = "")
        cat("  Overall maximum:", round(observed_curve_deviance$overall, 3), "\n")
        for (sex_level in names(observed_curve_deviance$by_sex)) {
          cat("  ", sex_level, ":", round(observed_curve_deviance$by_sex[[sex_level]], 3), "\n")
        }
      } else {
        cat("Observed curve deviance (", curve_method, "): ", round(observed_curve_deviance$overall, 3), "\n", sep = "")
      }
    }

    # Calculate p-values for curve tests using the already computed null distributions
    curve_p_value <- sum(null_curve_deviances >= observed_curve_deviance$overall, na.rm = TRUE) /
      sum(!is.na(null_curve_deviances))

    curve_p_values_by_sex <- NULL
    if (!is.null(sex)) {
      curve_p_values_by_sex <- numeric(length(sex_levels_for_curves))
      names(curve_p_values_by_sex) <- sex_levels_for_curves
      for (sex_level in sex_levels_for_curves) {
        curve_p_values_by_sex[sex_level] <-
          sum(null_curve_deviances_by_sex[, sex_level] >= observed_curve_deviance$by_sex[[sex_level]], na.rm = TRUE) /
            sum(!is.na(null_curve_deviances_by_sex[, sex_level]))
      }
    }

    # Determine significance
    curve_significant <- curve_p_value < alpha
    curve_significant_by_sex <- NULL
    if (!is.null(sex)) {
      curve_significant_by_sex <- curve_p_values_by_sex < alpha
    }

    if (verbose) {
      cat("\nCurve comparison results:\n")
      cat(sprintf(
        "Overall curve deviance: p = %.4f %s\n",
        curve_p_value, ifelse(curve_significant, "*", "")
      ))
      if (!is.null(sex)) {
        for (sex_level in names(curve_p_values_by_sex)) {
          cat(sprintf(
            "%s curve deviance: p = %.4f %s\n",
            sex_level, curve_p_values_by_sex[sex_level],
            ifelse(curve_significant_by_sex[sex_level], "*", "")
          ))
        }
      }
    }

    # Store curve results
    curve_results <- list(
      observed_deviance = observed_curve_deviance,
      p_value = curve_p_value,
      significant = curve_significant,
      null_deviances = null_curve_deviances,
      evaluation_ages = curve_ages,
      method = curve_method
    )

    if (!is.null(sex)) {
      curve_results$p_values_by_sex <- curve_p_values_by_sex
      curve_results$significant_by_sex <- curve_significant_by_sex
      curve_results$null_deviances_by_sex <- null_curve_deviances_by_sex
    }
  }

  # Prepare results
  result <- list(
    observed_diffs = observed_diffs,
    p_values = p_values,
    significant = significant,
    group_parameters = group_params,
    null_distributions = null_diffs,
    curve_comparison = curve_results,
    method_info = list(
      n_bootstrap = n_bootstrap,
      alpha = alpha,
      parameters_tested = test_parameters,
      original_parameters = parameters,
      has_sex = !is.null(sex),
      sex_levels = if (!is.null(sex)) levels(sex) else NULL,
      n_groups = length(group_levels),
      group_names = group_levels,
      sample_sizes = as.numeric(table(group)),
      total_n = length(age),
      age_stratified = age_stratified,
      age_bin_width = if (age_stratified) age_bin_width else NULL,
      age_range = c(min(age), max(age)),
      test_curves = test_curves,
      curve_method = if (test_curves) curve_method else NULL,
      curve_ages_range = if (test_curves && !is.null(curve_ages)) c(min(curve_ages), max(curve_ages)) else NULL
    )
  )

  class(result) <- "vb_comparison"
  return(result)
}

#' Summary Method for Von Bertalanffy Growth Parameter Comparison
#'
#' Provides a formatted summary of bootstrap permutation test results for
#' von Bertalanffy growth parameter comparisons between groups.
#'
#' @param object A \code{vb_comparison} object returned by \code{compare_vb_mle}
#' @param digits Number of decimal places for numeric output (default 4)
#' @param ... Additional arguments (currently unused)
#'
#' @details
#' The summary provides:
#' \itemize{
#'   \item Test method and configuration details
#'   \item Sample sizes and group information
#'   \item Parameter estimates for each group
#'   \item Statistical test results with p-values and significance
#'   \item Growth curve comparison results (if performed)
#' }
#'
#' @return Invisibly returns the input object after printing the summary
#'
#' @examples
#' \dontrun{
#' # After running compare_vb_mle
#' result <- compare_vb_mle(age, length, group)
#' summary(result)
#' }
#'
#' @export
summary.vb_comparison <- function(object, digits = 4, ...) {
  info <- object$method_info

  # Header
  cat("Von Bertalanffy Growth Parameter Comparison\n")
  cat("==========================================\n\n")

  # Method information
  cat("Test Method:\n")
  cat("  Bootstrap permutation test with", info$n_bootstrap, "iterations\n")
  cat("  Significance level: alpha =", info$alpha, "\n")
  if (info$age_stratified) {
    cat("  Age-stratified permutation with", info$age_bin_width, "year age bins\n")
  } else {
    cat("  Simple random permutation\n")
  }
  cat("\n")

  # Sample information
  cat("Sample Information:\n")
  cat("  Total observations:", info$total_n, "\n")
  cat("  Number of groups:", info$n_groups, "\n")
  cat("  Groups:", paste(info$group_names, collapse = ", "), "\n")
  cat("  Group sizes:", paste(paste(info$group_names, info$sample_sizes, sep = ": "), collapse = ", "), "\n")
  cat("  Age range:", round(info$age_range[1], 1), "to", round(info$age_range[2], 1), "years\n")

  if (info$has_sex) {
    cat("  Sex-specific models fitted for:", paste(info$sex_levels, collapse = ", "), "\n")
  }
  cat("\n")

  # Parameter estimates
  cat("Parameter Estimates by Group:\n")
  param_matrix <- object$group_parameters

  # Format parameter matrix for display
  formatted_params <- apply(param_matrix, 2, function(x) {
    ifelse(is.na(x), "NA", sprintf(paste0("%.", digits, "f"), x))
  })

  if (is.vector(formatted_params)) {
    # Single parameter case
    formatted_params <- matrix(formatted_params, nrow = nrow(param_matrix))
    colnames(formatted_params) <- colnames(param_matrix)
    rownames(formatted_params) <- rownames(param_matrix)
  }

  print(formatted_params, quote = FALSE)
  cat("\n")

  # Statistical test results
  cat("Statistical Test Results:\n")
  cat("  Parameters tested:", paste(info$parameters_tested, collapse = ", "), "\n\n")

  # Create results table
  results_df <- data.frame(
    Parameter = names(object$p_values),
    Observed_Diff = sprintf(paste0("%.", digits, "f"), object$observed_diffs),
    P_Value = sprintf(paste0("%.", digits, "f"), object$p_values),
    Significant = ifelse(object$significant, "Yes", "No"),
    stringsAsFactors = FALSE
  )

  # Handle NA values
  results_df$Observed_Diff[is.na(object$observed_diffs)] <- "NA"
  results_df$P_Value[is.na(object$p_values)] <- "NA"
  results_df$Significant[is.na(object$significant)] <- "NA"

  print(results_df, row.names = FALSE)

  # Count significant results
  n_significant <- sum(object$significant, na.rm = TRUE)
  n_tested <- sum(!is.na(object$significant))
  cat("\n")
  cat("  Summary:", n_significant, "of", n_tested, "parameters show significant differences\n")

  # Growth curve comparison results
  if (info$test_curves && !is.null(object$curve_comparison)) {
    cat("\n")
    cat("Growth Curve Comparison:\n")
    cat("  Method:", info$curve_method, "\n")

    curve_res <- object$curve_comparison

    if (!is.null(info$curve_ages_range)) {
      cat(
        "  Curves evaluated from age", round(info$curve_ages_range[1], 1),
        "to", round(info$curve_ages_range[2], 1), "years\n"
      )
    }
    cat("  Evaluation points:", length(curve_res$evaluation_ages), "\n")

    if (info$has_sex) {
      cat("  Overall maximum deviance:", sprintf(paste0("%.", digits, "f"), curve_res$observed_deviance$overall), "\n")
      cat(
        "  Overall curve p-value:", sprintf(paste0("%.", digits, "f"), curve_res$p_value),
        ifelse(curve_res$significant, " *", ""), "\n"
      )

      cat("  Sex-specific results:\n")
      for (sex_level in names(curve_res$observed_deviance$by_sex)) {
        cat(
          "    ", sex_level, "- Deviance:",
          sprintf(paste0("%.", digits, "f"), curve_res$observed_deviance$by_sex[[sex_level]]),
          ", p-value:", sprintf(paste0("%.", digits, "f"), curve_res$p_values_by_sex[sex_level]),
          ifelse(curve_res$significant_by_sex[sex_level], " *", ""), "\n"
        )
      }
    } else {
      cat("  Maximum curve deviance:", sprintf(paste0("%.", digits, "f"), curve_res$observed_deviance$overall), "\n")
      cat(
        "  Curve comparison p-value:", sprintf(paste0("%.", digits, "f"), curve_res$p_value),
        ifelse(curve_res$significant, " *", ""), "\n"
      )
    }

    if (curve_res$significant || (info$has_sex && any(curve_res$significant_by_sex, na.rm = TRUE))) {
      cat("  Result: Significant differences in growth curves detected\n")
    } else {
      cat("  Result: No significant differences in growth curves detected\n")
    }
  }

  cat("\n")
  cat("* indicates significance at alpha =", info$alpha, "\n")
  cat("\nNote: P-values calculated as the proportion of bootstrap permutations\n")
  cat("      with differences greater than or equal to the observed difference.\n")

  invisible(object)
}

#' Print Method for Von Bertalanffy Growth Parameter Comparison
#'
#' Provides a concise summary of bootstrap permutation test results for
#' von Bertalanffy growth parameter comparisons between groups.
#'
#' @param x A \code{vb_comparison} object returned by \code{compare_vb_mle}
#' @param ... Additional arguments passed to \code{summary.vb_comparison}
#'
#' @details
#' This is a simplified wrapper around the summary method that provides
#' the same detailed output. For more control over formatting, use
#' \code{summary()} directly.
#'
#' @return Invisibly returns the input object after printing the summary
#'
#' @examples
#' \dontrun{
#' # After running compare_vb_mle
#' result <- compare_vb_mle(age, length, group)
#' print(result) # or simply: result
#' }
#'
#' @export
print.vb_comparison <- function(x, ...) {
  summary.vb_comparison(x, ...)
}

#' Plot Permutation Test Results for Von Bertalanffy Growth Parameter Comparison
#'
#' Creates density plots showing the null distributions from bootstrap permutation
#' tests with observed test statistics overlaid. This visualisation helps assess
#' the significance of parameter differences and curve comparisons.
#'
#' @param x A \code{vb_comparison} object returned by \code{compare_vb_mle}
#' @param parameters Character vector of parameters to plot. If NULL, plots all tested parameters.
#'   For sex models, use sex-specific names (e.g., "Linf_M", "Linf_F")
#' @param include_curves Logical, whether to include curve comparison plot (default TRUE if available)
#' @param ncol Number of columns for plot layout (default 2)
#' @param alpha Transparency for density plots (default 0.5)
#' @param observed_colour Colour for observed test statistic line (default "red")
#' @param observed_size Line width for observed test statistic (default 1)
#' @param title_size Font size for plot titles (default 11)
#' @param ... Additional arguments passed to plotting functions
#'
#' @details
#' The function creates:
#' \itemize{
#'   \item Density plots of null distributions for each parameter
#'   \item Vertical lines showing observed test statistics
#'   \item P-values and significance indicators in plot titles
#'   \item Optional curve comparison plot (if test_curves was TRUE)
#' }
#'
#' For sex-specific models, separate plots are created for each sex's parameters.
#' The null distribution represents the expected range of differences under the
#' hypothesis of no group differences. Observed statistics falling in the tail
#' regions indicate significant differences.
#'
#' @return A ggplot object (single plot) or list of ggplot objects (multiple plots)
#'
#' @examples
#' \dontrun{
#' # After running compare_vb_mle
#' result <- compare_vb_mle(age, length, group, n_bootstrap = 500)
#'
#' # Plot all parameters
#' plot(result)
#'
#' # Plot specific parameters
#' plot(result, parameters = c("Linf", "k"))
#'
#' # Plot without curve comparison
#' plot(result, include_curves = FALSE)
#'
#' # Customise appearance
#' plot(result, observed_colour = "blue", alpha = 0.5, ncol = 3)
#' }
#'
#' @export
plot.vb_comparison <- function(x, parameters = NULL, include_curves = TRUE,
                               ncol = 2, alpha = 0.5, observed_colour = "red",
                               observed_size = 1.0, title_size = 11, ...) {
  # Check if ggplot2 is available
  if (!requireNamespace("ggplot2", quietly = TRUE)) {
    stop("ggplot2 is required for plotting. Please install it with: install.packages('ggplot2')")
  }

  # Check if gridExtra is available for multi-panel plots
  if (!requireNamespace("gridExtra", quietly = TRUE)) {
    stop("gridExtra is required for multi-panel plotting. Please install it with: install.packages('gridExtra')")
  }

  # Check if grid is available
  if (!requireNamespace("grid", quietly = TRUE)) {
    stop("grid is required for plotting. Please install it with: install.packages('grid')")
  }

  # Determine which parameters to plot
  available_params <- names(x$observed_diffs)[!is.na(x$observed_diffs)]
  if (is.null(parameters)) {
    parameters <- available_params
  } else {
    # Check that requested parameters are available
    missing_params <- setdiff(parameters, available_params)
    if (length(missing_params) > 0) {
      warning("Parameters not found or have NA values: ", paste(missing_params, collapse = ", "))
      parameters <- intersect(parameters, available_params)
    }
  }

  if (length(parameters) == 0) {
    stop("No valid parameters available for plotting")
  }

  # Create list to store plots
  plot_list <- list()

  # Create parameter plots
  for (param in parameters) {
    # Extract null distribution and observed value
    null_dist <- x$null_distributions[, param]
    null_dist <- null_dist[!is.na(null_dist)]
    observed <- x$observed_diffs[param]
    p_value <- x$p_values[param]
    is_significant <- x$significant[param]

    if (length(null_dist) == 0) {
      warning("No valid null distribution data for parameter: ", param)
      next
    }

    # Create data frame for plotting
    plot_data <- data.frame(
      value = null_dist,
      type = "Null Distribution"
    )

    # Create significance indicator
    sig_indicator <- ifelse(is_significant, " *", "")

    # Create the plot
    p <- ggplot2::ggplot(plot_data, ggplot2::aes(x = value)) +
      ggplot2::geom_density(alpha = alpha, fill = "lightblue", colour = "darkblue") +
      ggplot2::geom_vline(
        xintercept = observed, colour = observed_colour,
        linewidth = observed_size, linetype = "solid"
      ) +
      ggplot2::labs(
        title = paste0(param, ": p = ", sprintf("%.4f", p_value), sig_indicator),
        x = "Test Statistic (Maximum Difference)",
        y = "Density"
      ) +
      ggplot2::theme(
        plot.title = ggplot2::element_text(size = title_size, hjust = 0.5),
        axis.title = ggplot2::element_text(size = 10),
        axis.text = ggplot2::element_text(size = 9)
      ) +
      ggplot2::annotate("text",
        x = observed, y = 0,
        label = paste("Observed:", round(observed, 3)),
        hjust = -0.1, vjust = -0.5, size = 3, colour = observed_colour
      )

    plot_list[[param]] <- p
  }

  # Add curve comparison plot if requested and available
  if (include_curves && !is.null(x$curve_comparison)) {
    curve_res <- x$curve_comparison

    # Extract null distribution and observed value for curves
    null_curve_dist <- curve_res$null_deviances
    null_curve_dist <- null_curve_dist[!is.na(null_curve_dist)]
    observed_curve <- curve_res$observed_deviance$overall
    curve_p_value <- curve_res$p_value
    curve_significant <- curve_res$significant

    if (length(null_curve_dist) > 0) {
      # Create data frame for curve plotting
      curve_plot_data <- data.frame(
        value = null_curve_dist,
        type = "Null Distribution"
      )

      # Create significance indicator
      curve_sig_indicator <- ifelse(curve_significant, " *", "")

      # Create the curve plot
      curve_plot <- ggplot2::ggplot(curve_plot_data, ggplot2::aes(x = value)) +
        ggplot2::geom_density(alpha = alpha, fill = "lightgreen", colour = "darkgreen") +
        ggplot2::geom_vline(
          xintercept = observed_curve, colour = observed_colour,
          linewidth = observed_size, linetype = "solid"
        ) +
        ggplot2::labs(
          title = paste0("Growth Curves: p = ", sprintf("%.4f", curve_p_value), curve_sig_indicator),
          x = "Maximum Curve Deviance",
          y = "Density"
        ) +
        ggplot2::theme(
          plot.title = ggplot2::element_text(size = title_size, hjust = 0.5),
          axis.title = ggplot2::element_text(size = 10),
          axis.text = ggplot2::element_text(size = 9)
        ) +
        ggplot2::annotate("text",
          x = observed_curve, y = 0,
          label = paste("Observed:", round(observed_curve, 3)),
          hjust = -0.1, vjust = -0.5, size = 3, colour = observed_colour
        )

      plot_list[["Growth_Curves"]] <- curve_plot
    }
  }

  # Handle single plot vs multiple plots
  if (length(plot_list) == 1) {
    return(plot_list[[1]])
  } else {
    # Calculate number of rows needed
    nrow <- ceiling(length(plot_list) / ncol)

    # Create combined plot
    combined_plot <- gridExtra::grid.arrange(grobs = plot_list, ncol = ncol, nrow = nrow)

    # Add overall title
    title_grob <- grid::textGrob(
      "Bootstrap Permutation Test Results",
      gp = grid::gpar(fontsize = 14, fontface = "bold")
    )

    final_plot <- gridExtra::grid.arrange(
      title_grob, combined_plot,
      heights = grid::unit(c(0.1, 0.9), "npc")
    )

    return(final_plot)
  }
}
