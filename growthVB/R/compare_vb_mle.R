#' Compare Von Bertalanffy Growth Parameters Between Groups Using Bootstrap Permutation Test
#'
#' This function performs a bootstrap permutation test to evaluate whether von Bertalanffy
#' growth parameters differ significantly between two or more groups. The test compares
#' the observed differences in parameters against a null distribution generated by
#' randomly permuting group labels.
#'
#' @param age A numeric vector of ages
#' @param length A numeric vector of lengths
#' @param group A factor or character vector specifying the group for each observation
#' @param sex Optional factor or character vector specifying sex for each observation (for sex-specific models)
#' @param n_bootstrap Number of bootstrap permutations (default 1000)
#' @param parameters Character vector of parameters to test. Options: "Linf", "k", "t0", "CV" (default all).
#'   For sex models, parameters are automatically expanded to sex-specific versions (e.g., "Linf_M", "Linf_F")
#' @param alpha Significance level for the test (default 0.05)
#' @param verbose Logical, whether to print progress messages (default TRUE)
#' @param seed Optional seed for reproducible results
#' @param min_obs Minimum number of observations required per sex/group combination (default 50).
#'   Combinations with fewer observations will be removed before analysis
#' @param age_stratified Logical, whether to use age-stratified permutation (default TRUE).
#'   When TRUE, permutations are performed within age bins to maintain age distribution
#' @param age_bin_width Width of age bins in years for stratified permutation (default 2).
#'   Only used when age_stratified = TRUE. Each bin will span this many years.
#'
#' @return A list containing:
#' \itemize{
#'   \item \code{observed_diffs}: Observed differences between groups for each parameter
#'   \item \code{p_values}: P-values for each parameter comparison
#'   \item \code{significant}: Logical indicating which parameters show significant differences
#'   \item \code{group_parameters}: Parameter estimates for each group
#'   \item \code{null_distributions}: Bootstrap null distributions for each parameter
#'   \item \code{method_info}: Information about the test method and settings
#' }
#'
#' @details
#' The function fits separate von Bertalanffy models to each group, then performs
#' a bootstrap permutation test by:
#' \enumerate{
#'   \item Computing observed parameter differences between groups
#'   \item Randomly permuting group labels n_bootstrap times (with optional age stratification)
#'   \item Fitting models to each permuted dataset
#'   \item Computing parameter differences for each permutation
#'   \item Calculating p-values as the proportion of permuted differences
#'       that exceed the observed differences
#' }
#'
# When \code{age_stratified = TRUE} (default), permutations are performed within
#' age bins to ensure that age distributions remain comparable between groups.
#' This is crucial for validity as it tests differences in growth parameters
#' rather than differences in age distribution. Age bins are created using
#' \code{age_bin_width} to define the width of each bin in years.
#'
#' For multiple groups, the test statistic is the maximum pairwise difference
#' between any two groups for each parameter.
#'
#' @examples
#' \dontrun{
#' # Simulate data for two groups with different growth parameters
#' set.seed(123)
#' n_per_group <- 50
#' age1 <- runif(n_per_group, 1, 15)
#' age2 <- runif(n_per_group, 1, 15)
#'
#' # Group 1: Linf=100, k=0.2
#' length1 <- 100 * (1 - exp(-0.2 * (age1 - (-0.5)))) + rnorm(n_per_group, 0, 8)
#' # Group 2: Linf=120, k=0.15 (different parameters)
#' length2 <- 120 * (1 - exp(-0.15 * (age2 - (-0.5)))) + rnorm(n_per_group, 0, 10)
#'
#' age <- c(age1, age2)
#' length <- c(length1, length2)
#' group <- rep(c("Population_A", "Population_B"), each = n_per_group)
#'
#' # Test for differences in basic parameters
#' result <- compare_vb_mle(
#'   age = age, length = length, group = group,
#'   n_bootstrap = 500, seed = 123
#' )
#'
#' # Test with sex-specific models
#' sex <- rep(c("M", "F"), length.out = length(age))
#' result_sex <- compare_vb_mle(
#'   age = age, length = length, group = group, sex = sex,
#'   n_bootstrap = 500, seed = 123
#' )
#'
#' # View results
#' print(result$p_values)
#' print(result$significant)
#' print(result$group_parameters)
#' }
#'
#' @export
compare_vb_mle <- function(age, length, group, sex = NULL, n_bootstrap = 1000,
                           parameters = c("Linf", "k", "t0", "CV"),
                           alpha = 0.05, verbose = TRUE, seed = NULL, min_obs = 50,
                           age_stratified = TRUE, age_bin_width = 2) {
  # Set seed for reproducibility if provided
  if (!is.null(seed)) {
    set.seed(seed)
  }

  # Input validation
  if (length(age) != length(length) || length(age) != length(group)) {
    stop("age, length, and group must have the same length")
  }

  if (!is.null(sex) && length(sex) != length(age)) {
    stop("sex must have the same length as age, length, and group")
  }

  # Remove missing values
  if (is.null(sex)) {
    complete_cases <- complete.cases(age, length, group)
    age <- age[complete_cases]
    length <- length[complete_cases]
    group <- as.factor(group)[complete_cases]
    sex <- NULL
  } else {
    complete_cases <- complete.cases(age, length, group, sex)
    age <- age[complete_cases]
    length <- length[complete_cases]
    group <- as.factor(group)[complete_cases]
    sex <- as.factor(sex)[complete_cases]
  }

  if (verbose) {
    cat("Removed", sum(!complete_cases), "incomplete cases\n")
    cat("Analysing", length(age), "observations\n")
  }

  # Filter out sex/group combinations with insufficient observations
  if (!is.null(sex) && min_obs > 0) {
    # Create sex/group combinations
    sex_group_combo <- interaction(sex, group, drop = TRUE)
    combo_counts <- table(sex_group_combo)

    # Identify combinations with sufficient observations
    sufficient_combos <- names(combo_counts)[combo_counts >= min_obs]

    if (length(sufficient_combos) == 0) {
      stop("No sex/group combinations have >= ", min_obs, " observations")
    }

    # Filter to keep only sufficient combinations
    keep_indices <- sex_group_combo %in% sufficient_combos

    if (sum(!keep_indices) > 0) {
      insufficient_combos <- names(combo_counts)[combo_counts < min_obs]
      if (verbose) {
        cat(
          "Removed", sum(!keep_indices), "observations from", length(insufficient_combos),
          "sex/group combinations with < ", min_obs, " observations:\n"
        )
        for (combo in insufficient_combos) {
          cat("  ", combo, ": ", combo_counts[combo], " observations\n", sep = "")
        }
      }

      age <- age[keep_indices]
      length <- length[keep_indices]
      group <- droplevels(group[keep_indices])
      sex <- droplevels(sex[keep_indices])

      if (verbose) {
        cat("Remaining", length(age), "observations for analysis\n")
      }
    }
  } else if (is.null(sex) && min_obs > 0) {
    # For non-sex models, filter groups with insufficient observations
    group_counts <- table(group)
    sufficient_groups <- names(group_counts)[group_counts >= min_obs]

    if (length(sufficient_groups) == 0) {
      stop("No groups have >= ", min_obs, " observations")
    }

    keep_indices <- group %in% sufficient_groups

    if (sum(!keep_indices) > 0) {
      insufficient_groups <- names(group_counts)[group_counts < min_obs]
      if (verbose) {
        cat(
          "Removed", sum(!keep_indices), "observations from", length(insufficient_groups),
          "groups with < ", min_obs, " observations:\n"
        )
        for (grp in insufficient_groups) {
          cat("  ", grp, ": ", group_counts[grp], " observations\n", sep = "")
        }
      }

      age <- age[keep_indices]
      length <- length[keep_indices]
      group <- droplevels(group[keep_indices])

      if (verbose) {
        cat("Remaining", length(age), "observations for analysis\n")
      }
    }
  }

  # Check we have at least 2 groups
  group_levels <- levels(group)
  if (length(group_levels) < 2) {
    stop("Need at least 2 groups for comparison")
  }

  if (verbose) {
    cat("Comparing", length(group_levels), "groups:", paste(group_levels, collapse = ", "), "\n")
    cat("Group sizes:", table(group), "\n")
  }

  # Validate parameters
  valid_params <- c("Linf", "k", "t0", "CV")
  if (!all(parameters %in% valid_params)) {
    stop("parameters must be a subset of: ", paste(valid_params, collapse = ", "))
  }

  # Helper function to extract parameters from model fit
  extract_parameters <- function(fit) {
    if (!is.null(fit$models)) {
      # Sex-specific models - parameters are in fit$models$sex$parameters
      params <- list()
      for (sex_level in names(fit$models)) {
        sex_model <- fit$models[[sex_level]]
        sex_params <- sex_model$parameters
        for (param in c("Linf", "k", "t0", "cv")) {
          param_name <- paste0(toupper(substring(param, 1, 1)), substring(param, 2), "_", sex_level)
          if (param == "cv") param_name <- paste0("CV_", sex_level)
          params[[param_name]] <- sex_params[[param]]
        }
      }
      return(unlist(params))
    } else {
      # Single model - parameters is a matrix with rownames and "estimate" column
      params <- fit$parameters
      result <- c(
        Linf = params["Linf", "estimate"],
        k = params["k", "estimate"],
        t0 = params["t0", "estimate"],
        CV = params["cv", "estimate"] # Note: lowercase "cv" in row, uppercase "CV" in result
      )
      return(result)
    }
  }

  # Function to fit VB model to a group and extract parameters
  fit_group_model <- function(group_age, group_length, group_sex = NULL, start_vals = NULL) {
    tryCatch(
      {
        # Load the fit_vb_mle function (assuming it's available)
        if (!exists("fit_vb_mle")) {
          stop("fit_vb_mle function not found. Please load the growthVB package.")
        }

        fit <- fit_vb_mle(age = group_age, length = group_length, sex = group_sex, start_values = start_vals)
        return(extract_parameters(fit))
      },
      error = function(e) {
        warning(paste("Failed to fit model:", e$message))
        return(NULL)
      }
    )
  }

  # Function to calculate maximum pairwise difference for each parameter
  calc_max_diff <- function(param_matrix) {
    n_groups <- nrow(param_matrix)
    max_diffs <- numeric(ncol(param_matrix))
    names(max_diffs) <- colnames(param_matrix)

    for (p in 1:ncol(param_matrix)) {
      param_vals <- param_matrix[, p]
      if (all(!is.na(param_vals))) {
        max_diffs[p] <- max(param_vals) - min(param_vals)
      } else {
        max_diffs[p] <- NA
      }
    }
    return(max_diffs)
  }

  # Fit models to each group and get observed parameters
  if (verbose) cat("Fitting models to each group...\n")

  # First fit to determine parameter structure
  group_mask <- group == group_levels[1]
  group_age_test <- age[group_mask]
  group_length_test <- length[group_mask]
  group_sex_test <- if (!is.null(sex)) sex[group_mask] else NULL

  test_params <- fit_group_model(group_age_test, group_length_test, group_sex_test)
  if (is.null(test_params)) {
    stop("Failed to fit initial model to determine parameter structure")
  }

  # Determine which parameters to test based on model type
  available_params <- names(test_params)
  if (!is.null(sex)) {
    # For sex models, expand parameters to sex-specific versions
    test_parameters <- character(0)
    sex_levels <- levels(sex)
    for (param in parameters) {
      for (sex_level in sex_levels) {
        # Match the naming convention used in extract_parameters
        if (param == "CV") {
          param_name <- paste0("CV_", sex_level)
        } else {
          param_name <- paste0(toupper(substring(param, 1, 1)), substring(param, 2), "_", sex_level)
        }
        if (param_name %in% available_params) {
          test_parameters <- c(test_parameters, param_name)
        }
      }
    }
  } else {
    # For single models, use parameters as-is
    test_parameters <- intersect(parameters, available_params)
  }

  if (length(test_parameters) == 0) {
    stop("No valid parameters found for testing")
  }

  if (verbose) {
    cat("Testing parameters:", paste(test_parameters, collapse = ", "), "\n")
  }

  # Initialize parameter matrix and starting values storage
  group_params <- matrix(NA, nrow = length(group_levels), ncol = length(test_parameters))
  colnames(group_params) <- test_parameters
  rownames(group_params) <- group_levels

  # Store starting values for each group (for bootstrap efficiency)
  group_start_values <- list()

  # Store first group results
  group_params[1, ] <- test_params[test_parameters]

  # Extract starting values from first group for bootstrap
  if (!is.null(sex)) {
    # For sex models, we'll use a combined approach - average the sex-specific parameters
    group_start_values[[group_levels[1]]] <- list(
      Linf = mean(c(test_params[paste0("Linf_", levels(sex))]), na.rm = TRUE),
      k = mean(c(test_params[paste0("k_", levels(sex))]), na.rm = TRUE),
      t0 = mean(c(test_params[paste0("t0_", levels(sex))]), na.rm = TRUE),
      cv = mean(c(test_params[paste0("CV_", levels(sex))]), na.rm = TRUE)
    )
  } else {
    # For single models, use parameters directly
    group_start_values[[group_levels[1]]] <- list(
      Linf = test_params[["Linf"]],
      k = test_params[["k"]],
      t0 = test_params[["t0"]],
      cv = test_params[["CV"]]
    )
  }

  # Fit remaining groups
  for (i in 2:length(group_levels)) {
    group_mask <- group == group_levels[i]
    group_age_i <- age[group_mask]
    group_length_i <- length[group_mask]
    group_sex_i <- if (!is.null(sex)) sex[group_mask] else NULL

    if (length(group_age_i) >= 10) { # Minimum sample size check
      params_i <- fit_group_model(group_age_i, group_length_i, group_sex_i)
      if (!is.null(params_i)) {
        group_params[i, ] <- params_i[test_parameters]

        # Store starting values for bootstrap
        if (!is.null(sex)) {
          # For sex models, average the sex-specific parameters for starting values
          group_start_values[[group_levels[i]]] <- list(
            Linf = mean(c(params_i[paste0("Linf_", levels(sex))]), na.rm = TRUE),
            k = mean(c(params_i[paste0("k_", levels(sex))]), na.rm = TRUE),
            t0 = mean(c(params_i[paste0("t0_", levels(sex))]), na.rm = TRUE),
            cv = mean(c(params_i[paste0("CV_", levels(sex))]), na.rm = TRUE)
          )
        } else {
          # For single models, use parameters directly
          group_start_values[[group_levels[i]]] <- list(
            Linf = params_i[["Linf"]],
            k = params_i[["k"]],
            t0 = params_i[["t0"]],
            cv = params_i[["CV"]]
          )
        }
      }
    } else {
      warning(paste("Group", group_levels[i], "has fewer than 10 observations, skipping"))
    }
  }

  # Calculate observed differences
  observed_diffs <- calc_max_diff(group_params)
  observed_diffs <- observed_diffs[test_parameters]

  if (verbose) {
    cat("Observed parameter differences:\n")
    print(observed_diffs)
    cat("\nStarting bootstrap permutation test with", n_bootstrap, "iterations...\n")
    if (age_stratified) {
      cat("Using age-stratified permutation with", age_bin_width, "year age bins\n")
    }
  }

  # Prepare age bins for stratified permutation
  if (age_stratified) {
    # Create age bins based on bin width rather than number of bins
    min_age <- min(age)
    max_age <- max(age)
    age_breaks <- seq(from = min_age, to = max_age + age_bin_width, by = age_bin_width)
    age_bins <- cut(age, breaks = age_breaks, include.lowest = TRUE, right = FALSE)

    # Calculate actual number of bins created
    n_bins_created <- length(levels(age_bins))

    if (verbose) {
      cat("Age range:", round(min_age, 1), "to", round(max_age, 1), "\n")
      cat("Bin width:", age_bin_width, "years,", n_bins_created, "bins created\n")
      cat("Age bin sizes:", table(age_bins), "\n")
    }
  }

  # Bootstrap permutation test
  null_diffs <- matrix(NA, nrow = n_bootstrap, ncol = length(test_parameters))
  colnames(null_diffs) <- test_parameters

  # Progress reporting
  progress_points <- seq(0, n_bootstrap, by = max(1, n_bootstrap %/% 10))

  for (b in 1:n_bootstrap) {
    # Permute group labels (age-stratified or simple)
    if (age_stratified) {
      # Age-stratified permutation: permute within each age bin
      perm_group <- group # Start with original
      for (bin_level in levels(age_bins)) {
        bin_indices <- which(age_bins == bin_level)
        if (length(bin_indices) > 1) {
          # Permute group labels within this age bin
          perm_group[bin_indices] <- sample(group[bin_indices])
        }
      }
    } else {
      # Simple random permutation
      perm_group <- sample(group)
    }

    # Fit models to permuted groups using observed parameters as starting values
    perm_params <- matrix(NA, nrow = length(group_levels), ncol = length(test_parameters))
    colnames(perm_params) <- test_parameters

    for (i in seq_along(group_levels)) {
      group_mask <- perm_group == group_levels[i]
      group_age_i <- age[group_mask]
      group_length_i <- length[group_mask]
      group_sex_i <- if (!is.null(sex)) sex[group_mask] else NULL

      if (length(group_age_i) >= 10) {
        # Use starting values from the observed fit for this group (if available)
        start_vals <- group_start_values[[group_levels[i]]]
        params_i <- fit_group_model(group_age_i, group_length_i, group_sex_i, start_vals)
        if (!is.null(params_i)) {
          perm_params[i, ] <- params_i[test_parameters]
        }
      }
    }

    # Calculate differences for this permutation
    perm_diffs <- calc_max_diff(perm_params)
    null_diffs[b, ] <- perm_diffs[test_parameters]

    # Progress reporting
    if (verbose && b %in% progress_points) {
      cat("Completed", b, "of", n_bootstrap, "permutations\n")
    }
  }

  # Calculate p-values
  p_values <- numeric(length(test_parameters))
  names(p_values) <- test_parameters

  for (p in test_parameters) {
    if (!is.na(observed_diffs[p])) {
      # Two-tailed test: proportion of permuted differences >= observed difference
      p_values[p] <- sum(null_diffs[, p] >= observed_diffs[p], na.rm = TRUE) /
        sum(!is.na(null_diffs[, p]))
    } else {
      p_values[p] <- NA
    }
  }

  # Determine significance
  significant <- p_values < alpha

  if (verbose) {
    cat("\nResults:\n")
    for (p in test_parameters) {
      if (!is.na(p_values[p])) {
        cat(sprintf(
          "%s: p = %.4f %s\n", p, p_values[p],
          ifelse(significant[p], "*", "")
        ))
      } else {
        cat(sprintf("%s: p = NA (fitting failed)\n", p))
      }
    }
    cat("\n* indicates significance at alpha =", alpha, "\n")
  }

  # Prepare results
  result <- list(
    observed_diffs = observed_diffs,
    p_values = p_values,
    significant = significant,
    group_parameters = group_params,
    null_distributions = null_diffs,
    method_info = list(
      n_bootstrap = n_bootstrap,
      alpha = alpha,
      parameters_tested = test_parameters,
      original_parameters = parameters,
      has_sex = !is.null(sex),
      sex_levels = if (!is.null(sex)) levels(sex) else NULL,
      n_groups = length(group_levels),
      group_names = group_levels,
      sample_sizes = as.numeric(table(group)),
      total_n = length(age),
      age_stratified = age_stratified,
      age_bin_width = if (age_stratified) age_bin_width else NULL,
      age_range = c(min(age), max(age))
    )
  )

  class(result) <- "vb_comparison"
  return(result)
}
